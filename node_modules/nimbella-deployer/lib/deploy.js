"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.deployPackage=exports.actionWrap=exports.deployWebResource=exports.cleanPackage=exports.doDeploy=exports.cleanOrLoadVersions=void 0;const util_1=require("./util"),deploy_to_bucket_1=require("./deploy-to-bucket"),web_local_1=require("./web-local"),rimrafOrig=require("rimraf"),util_2=require("util"),makeDebug=require("debug"),debug=makeDebug("nim:deployer:deploy"),rimraf=util_2.promisify(rimrafOrig);async function cleanOrLoadVersions(e){if(e.flags.incremental)e.versions=util_1.loadVersions(e.filePath,e.credentials.namespace,e.credentials.ow.apihost);else{if(e.includer.isWebIncluded&&(e.cleanNamespace||e.bucket&&e.bucket.clean))if(e.bucketClient){const n=await deploy_to_bucket_1.cleanBucket(e.bucketClient,e.bucket,e.credentials.ow);n&&e.feedback.warn(n)}else e.flags.webLocal&&await rimraf(e.flags.webLocal);e.cleanNamespace&&e.includer.isIncludingEverything()?await util_1.wipe(e.owClient):await cleanActionsAndPackages(e)}return Promise.resolve(e)}function doDeploy(e){let n;e.flags.webLocal&&(n=web_local_1.ensureWebLocal(e.flags.webLocal));const a=e.web.map(a=>deployWebResource(a,e.actionWrapPackage,e.bucket,e.bucketClient,e.flags.incremental?e.versions:void 0,n,e.reader,e.credentials.ow));return util_1.getDeployerAnnotation(e.filePath,e.githubPath).then(n=>{const t=e.packages.map(a=>deployPackage(a,e.owClient,n,e.parameters,e.environment,e.cleanNamespace,e.flags.incremental?e.versions:void 0,e.reader)),o=util_1.straysToResponse(e.strays);return Promise.all(a.concat(t)).then(n=>{n.push(o);const a=util_1.combineResponses(n);return a.apihost=e.credentials.ow.apihost,a.namespace||(a.namespace=e.credentials.namespace),a})})}function cleanActionsAndPackages(e){if(!e.packages)return Promise.resolve(e);const n=[];for(const a of e.packages){const t="default"===a.name;if(a.clean&&!t&&e.includer.isPackageIncluded(a.name))n.push(cleanPackage(e.owClient,a.name,e.versions));else if(a.actions){const o=t?"":a.name+"/";for(const t of a.actions)t.clean&&e.includer.isActionIncluded(a.name,t.name)&&(delete e.versions.actionVersions[t.name],n.push(e.owClient.actions.delete(o+t.name).catch(()=>{})))}}return Promise.all(n).then(()=>e)}async function cleanPackage(e,n,a){for(debug("Cleaning package %s",n);;){const t=await e.packages.get({name:n}).catch(()=>{});if(!t)return{name:n};if(!t.actions||0===t.actions.length)return debug("No more actions, removing package"),a&&a.packageVersions&&delete a.packageVersions[n],e.packages.delete({name:n});for(const o of t.actions)debug("deleting action %s",o.name),a&&a.actionVersions&&delete a.actionVersions[o.name],await e.actions.delete({name:n+"/"+o.name})}}function deployWebResource(e,n,a,t,o,i,s,r){return n?Promise.resolve(util_1.emptyResponse()):i?web_local_1.deployToWebLocal(e,i,a):t?deploy_to_bucket_1.deployToBucket(e,t,a,o,s,r):Promise.resolve(util_1.wrapError(new Error(`No bucket client and/or bucket spec for '${e.simpleName}'`),"web resources"))}function actionWrap(e,n){return n.readFileContents(e.filePath).then(n=>{let a=String(n);a=a.split("\\").join("\\\\").split("`").join("\\`");const t=`\nconst body = \`${a}\`\n\nfunction main() {\n    return {\n       statusCode: 200,\n       headers: { 'Content-Type': '${e.mimeType}' },\n       body: body\n    }\n}`;return{name:e.simpleName.endsWith(".html")?e.simpleName.replace(".html",""):e.simpleName,file:e.filePath,runtime:"nodejs:default",binary:!1,web:!0,code:t,wrapping:e.filePath}})}async function deployPackage(e,n,a,t,o,i,s,r){if("default"===e.name)return Promise.all(e.actions.map(e=>deployAction(e,n,"",a,i,s,r))).then(util_1.combineResponses);let c;const l=util_1.digestPackage(e);if(s&&s.packageVersions&&s.packageVersions[e.name]&&l===s.packageVersions[e.name].digest){const n={};n[e.name]=s.packageVersions[e.name],c={successes:[],failures:[],ignored:[],packageVersions:n,actionVersions:{},namespace:void 0}}else{let s;e.clean||i||(s=await n.packages.get({name:e.name}).catch(()=>{}));const r=s&&s.annotations?util_1.makeDict(s.annotations):{};delete r.deployerAnnot;const p=a;p.digest=l.substring(0,8);const u=Object.assign({},r,e.annotations,{deployer:p}),d=util_1.keyVal(u),m={parameters:encodeParameters(Object.assign({},t,e.parameters),Object.assign({},o,e.environment)),annotations:d,publish:e.shared};await n.packages.update({name:e.name,package:m}).then(n=>{const a={};a[e.name]={version:n.version,digest:l},c={successes:[],failures:[],ignored:[],packageVersions:a,actionVersions:{},namespace:n.namespace}}).catch(n=>{c=util_1.wrapError(n,`package '${e.name}'`)})}const p=e.name+"/",u=e.actions.map(t=>deployAction(t,n,p,a,e.clean||i,s,r)).concat(Promise.resolve(c));return Promise.all(u).then(e=>util_1.combineResponses(e))}function deployAction(e,n,a,t,o,i,s){if(e.code)return deployActionFromCode(e,a,e.code,n,t,o,i);const r=e.file;return s.readFileContents(r).then(n=>e.binary?n.toString("base64"):String(n)).then(s=>deployActionFromCode(e,a,s,n,t,o,i)).catch(n=>Promise.resolve(util_1.wrapError(n,`action '${a}${e.name}'`)))}function encodeParameters(e,n){let a=[];if(e&&(a=util_1.keyVal(e)),n){const e=util_1.keyVal(n);e.forEach(e=>{e.init=!0}),a=a.concat(e)}return a}async function deployActionFromCode(e,n,a,t,o,i,s){const r=n+e.name,c=e.runtime;if(!c)return Promise.resolve(util_1.wrapError(new Error(`Action '${r}' not deployed: runtime type could not be determined`),"action "+r));const l=util_1.digestAction(e,a);if(s&&s.actionVersions&&s.actionVersions[r]&&l===s.actionVersions[r].digest){const e={};return e[r]=s.actionVersions[r],Promise.resolve(util_1.wrapSuccess(r,"action",!0,void 0,e,void 0))}const p=e.annotations||{},u=o;let d;if(u.digest=l.substring(0,8),u.zipped=e.zipped,p.deployer=u,!0===e.web?(p["web-export"]=!0,p.final=!0,p["raw-http"]=!1):"raw"===e.web?(p["web-export"]=!0,p.final=!0,p["raw-http"]=!0):e.web||(p["web-export"]=!1,p.final=!1,p["raw-http"]=!1),"string"==typeof e.webSecure||!0===e.webSecure?p["require-whisk-auth"]=e.webSecure:e.webSecure||(p["require-whisk-auth"]=!1),!e.clean&&!i){const e={name:r,code:!1};d=await t.actions.get(e).catch(()=>{})}const m=d&&d.annotations?util_1.makeDict(d.annotations):{},g=Object.assign({},m,p);!1===g["require-whisk-auth"]&&delete g["require-whisk-auth"];const b=encodeParameters(e.parameters,e.environment),f={code:a,binary:e.binary,kind:c,main:e.main},k={annotations:util_1.keyVal(g),parameters:b,exec:f};e.limits&&(k.limits=e.limits);const w={name:r,action:k};return t.actions.update(w).then(n=>{const a={};a[r]={version:n.version,digest:l};const t=n.namespace.split("/")[0];return Promise.resolve(util_1.wrapSuccess(r,"action",!1,e.wrapping,a,t))}).catch(e=>Promise.resolve(util_1.wrapError(e,`action '${r}'`)))}exports.cleanOrLoadVersions=cleanOrLoadVersions,exports.doDeploy=doDeploy,exports.cleanPackage=cleanPackage,exports.deployWebResource=deployWebResource,exports.actionWrap=actionWrap,exports.deployPackage=deployPackage;
