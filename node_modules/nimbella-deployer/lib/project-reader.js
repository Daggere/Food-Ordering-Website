"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.assembleInitialStructure=exports.buildStructureParts=exports.readTopLevel=void 0;const path=require("path"),api_1=require("./api"),util_1=require("./util"),finder_builder_1=require("./finder-builder"),github_1=require("./github"),makeDebug=require("debug"),file_reader_1=require("./file-reader"),github_reader_1=require("./github-reader"),debug=makeDebug("nim:deployer:project-reader"),CONFIG_FILE="project.yml",LEGACY_CONFIG_FILE="projectConfig.yml",ENV_FILE=".env";async function readTopLevel(e,t,r,a,i){let n,s;if(debug("readTopLevel with filePath:'%s' and mustBeLocal:'%s'",e,String(a)),debug("feedback is %O",i),github_1.isGithubRef(e)){const t=github_1.parseGithubRef(e);t.auth||i.warn("Warning: access to GitHub will be un-authenticated; rate will be severely limited"),n=e,a?(debug("github path which must be local, making file reader"),e=await github_1.fetchProject(t,api_1.getUserAgent()),s=file_reader_1.makeFileReader(e)):(debug("Github path which can be remote, making Github reader"),s=github_reader_1.makeGithubReader(t,api_1.getUserAgent()))}else debug("not a github path, making file reader"),s=file_reader_1.makeFileReader(e);return s.readdir("").then(a=>{let o,c,u,l,d;a=util_1.filterFiles(a);const b=[];for(const i of a)if(i.isDirectory)switch(i.name){case"web":r.isWebIncluded&&(o="web");break;case"packages":d="packages";break;case".nimbella":break;default:b.push(i.name)}else i.isDirectory||i.name!==CONFIG_FILE?i.isDirectory||i.name!==LEGACY_CONFIG_FILE?i.isDirectory||!i.name.endsWith(".yml")&&!i.name.endsWith(".yaml")?t||i.isDirectory||".env"!==i.name?b.push(i.name):t=path.join(e,i.name):u=i.name:l=i.name:c=i.name;l&&!c&&(c=l,i.warn("Warning: the name 'projectConfig.yml' is deprecated; please rename to 'project.yml' soon")),u&&!c&&i.warn("Warning: found %s but no %s",u,CONFIG_FILE),n&&(debug("githhub path was %s",n),debug("filePath is %s",e));const g={web:o,packages:d,config:c,strays:b,filePath:e,env:t,githubPath:n,includer:r,reader:s,feedback:i};return debug("readTopLevel returning %O",g),g})}async function buildStructureParts(e){const{web:t,packages:r,config:a,strays:i,filePath:n,env:s,githubPath:o,includer:c,reader:u,feedback:l}=e;let d=r;o&&r&&(d=path.join(o,r)),debug("display path for actions is %O",d);return[await finder_builder_1.getBuildForWeb(t,u).then(e=>buildWebPart(t,e,u)),await buildActionsPart(r,d,c,u),await readConfig(a,s,n,i,o,c,u,l)]}function assembleInitialStructure(e){debug("Assembling structure from parts");const[t,r,a]=e,i=e.find(e=>e.error);if(i)return i;const n=(r.strays||[]).concat(a.strays||[]);return a.strays=n,a.web=t.web&&a.web?mergeWeb(t.web,a.web):t.web?t.web:a.web?a.web:[],a.packages=r.packages&&a.packages?mergePackages(r.packages,a.packages):r.packages?r.packages:a.packages?a.packages:[],adjustWebExportFlags(a.packages),a.webBuild=t.webBuild,a.actionWrapPackage&&a.web.forEach(e=>{if(e.simpleName.includes("/"))throw new Error(`Web resource ${e.simpleName} cannot be deployed with action-wrapping (has nested structure)`)}),a}function mergeWeb(e,t){const r={};e.forEach(e=>{r[e.simpleName]=e}),t.forEach(e=>{const t=r[e.simpleName];r[e.simpleName]=t?mergeWebResource(t,e):e});const a=[];for(const e in r)a.push(r[e]);return a}function mergeWebResource(e,t){if(e.filePath&&t.filePath)throw new Error("Config may not specify filePath for WebResource that already has a filePath");const r=Object.assign({},e,t);if(!r.filePath)throw new Error(`WebResource ${e.simpleName} has no filePath`);return r}function mergePackages(e,t){const r={};e.forEach(e=>{r[e.name]=e}),t.forEach(e=>{const t=r[e.name];if(!t)throw new Error(`Package '${e.name}' is named in the config but does not exist in the project`);r[e.name]=mergePackage(t,e)});const a=[];for(const e in r)a.push(r[e]);return a}function mergePackage(e,t){const r=e.actions,a=t.actions,i=Object.assign({},e,t);return r&&r.length>0?a&&a.length>0?i.actions=mergeActions(r,a):i.actions=r:i.actions=a,i}function adjustWebExportFlags(e){e.forEach(e=>{e.actions&&e.actions.forEach(t=>{void 0===t.web&&(t.web=void 0===e.web||e.web)})})}function mergeActions(e,t){const r={};e.forEach(e=>{r[e.name]=e}),t.forEach(e=>{const t=r[e.name];if(!t)throw new Error(`Action '${e.name}' is named in the config but does not exist in the project`);r[e.name]=mergeAction(t,e)});const a=[];for(const e in r)a.push(r[e]);return a}function mergeAction(e,t){debug("Action from filesystem: %O",e),debug("Action from config: %O",t);const r=Object.assign({},e,t);return debug("Result of merge: %O",r),r}function buildWebPart(e,t,r){return e?readWebResources(e,r).then(e=>({web:e,webBuild:t,packages:[],strays:[]})):Promise.resolve(util_1.emptyStructure())}function readWebResources(e,t){return debug("readWebResources for %s",e),util_1.promiseFilesAndFilterFiles(e,t).then(t=>util_1.convertToResources(t,e.length+1))}function buildActionsPart(e,t,r,a){return e?buildPkgArray(e,t,r,a).then(e=>{const[t,r]=e;return{web:[],packages:r,strays:t}}):Promise.resolve(util_1.emptyStructure())}function buildPkgArray(e,t,r,a){return debug("Building package array"),a.readdir(e).then(i=>{const n=(i=util_1.filterFiles(i)).filter(e=>!e.isDirectory).map(e=>e.name),s=i.filter(e=>e.isDirectory).map(e=>e.name),o=[];for(const i of s)if(r.isPackageIncluded(i)){const n=path.join(e,i);o.push(readPackage(n,path.join(t,i),i,r,a))}return Promise.all([Promise.resolve(n),Promise.all(o)])})}function readPackage(e,t,r,a,i){return debug("reading information for package '%s' with display path '%s'",e,t),i.readdir(e).then(n=>{n=util_1.filterFiles(n);const s=[],o={};for(const c of n){const n=path.join(e,c.name),u=path.join(t,c.name);if(debug("item %s has display path %s",c.name,u),c.isDirectory){if(c.isDirectory){if(!a.isActionIncluded(r,c.name))continue;const e=o[c.name];if(e)throw duplicateName(c.name,e,"*");o[c.name]="*",s.push(finder_builder_1.getBuildForAction(n,i).then(e=>({name:c.name,file:n,displayFile:u,build:e})))}}else{const{name:e,runtime:t,binary:i,zipped:l}=util_1.actionFileToParts(c.name);if(!a.isActionIncluded(r,e))continue;const d=o[e];if(d)throw duplicateName(e,d,t);o[e]=t,s.push(Promise.resolve({name:e,file:n,displayFile:u,runtime:t,binary:i,zipped:l}))}}return Promise.all(s)}).then(e=>({name:r,actions:e,shared:!1}))}function duplicateName(e,t,r){return new Error(`The action name '${e}' appears twice, once ${"*"===t?"as a directory":`with runtime '${t}'`} and once ${"*"===r?"as a directory":`with runtime '${r}'`}`)}function readConfig(e,t,r,a,i,n,s,o){const c={strays:a,filePath:r,githubPath:i,includer:n,reader:s,feedback:o};if(!e){debug("No config file found");const e=Object.assign({},util_1.emptyStructure(),c);return Promise.resolve(e)}return debug("Reading config file"),util_1.loadProjectConfig(e,t,r,s,o).then(e=>trimConfigWithIncluder(e,n)).then(e=>Object.assign({},e,c)).catch(e=>util_1.errorStructure(e))}function trimConfigWithIncluder(e,t){if(t.isWebIncluded||(e.web=[],e.bucket=void 0,e.actionWrapPackage=""),e.packages){const r=[];for(const a of e.packages)t.isPackageIncluded(a.name)&&(a.actions&&(a.actions=a.actions.filter(e=>t.isActionIncluded(a.name,e.name))),r.push(a));e.packages=r}return e}exports.readTopLevel=readTopLevel,exports.buildStructureParts=buildStructureParts,exports.assembleInitialStructure=assembleInitialStructure;
