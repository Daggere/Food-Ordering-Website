"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parseAPIHost=exports.disambiguateNamespace=exports.NimBaseCommand=exports.CaptureLogger=exports.NimFeedback=exports.setHelpHelper=void 0;const command_1=require("@oclif/command"),util_1=require("util"),http_1=require("http"),credentials_1=require("./credentials"),createDebug=require("debug"),debug=createDebug("nim:base"),verboseError=createDebug("nim:error");let helpHelper;function setHelpHelper(e){helpHelper=e}exports.setHelpHelper=setHelpHelper;class NimFeedback{constructor(e){this.logger=e}warn(e,...r){this.logger.log(String(e),...r)}progress(e,...r){this.logger.log(String(e),...r)}}exports.NimFeedback=NimFeedback;class CaptureLogger{constructor(){this.captured=[]}log(e="",...r){const t=String(e).split("\n");for(const e of t)this.captured.push(util_1.format(e,...r))}handleError(e,r){if(r)throw r;throw e=improveErrorMsg(e,r),new Error(e)}displayError(e,r){e=improveErrorMsg(e,r),this.log("Error: %s",e)}exit(e){}logJSON(e){this.entity=e}}function isCaptureLogger(e){return"captured"in e}exports.CaptureLogger=CaptureLogger;class AioCommand extends command_1.Command{constructor(e,r){super(e,r)}handleError(e,r){}logJSON(e,r){}table(e,r,t={}){}async run(e){}}class NimBaseCommand extends command_1.Command{constructor(){super(...arguments),this.makeLogJSON=e=>(r,t)=>{e.entity=t},this.saveTable=e=>(r,t,s={})=>{debug("Call to saveTable with %O",r),e.table=r}}doHelp(){helpHelper&&this.usage?helpHelper(this.usage):this._help()}logJSON(e){const r=JSON.stringify(e,null,2).split("\n");for(const e of r)this.log(e)}async run(){const{argv:e,args:r,flags:t}=this.parse(this.constructor);debug("run with rawArgv: %O, argv: %O, args: %O, flags: %O",this.argv,e,r,t);const s=e.find(e=>e.startsWith("-"));s&&this.handleError("Unrecognized flag: "+s);const o=this.config.options,a=o?o.logger:void 0;await this.runCommand(this.argv,e,r,t,a||this)}async runAio(e,r,t,s,o,a){debug("runAio with rawArgv: %O, argv: %O, args: %O, flags: %O",e,r,t,s),fixAioCredentials(o,s);const i=new a(e,{});s.verbose&&(debug("verbose flag intercepted"),s.verbose=!1,verboseError.enabled=!0),isCaptureLogger(o)?(i.log=o.log.bind(o),i.exit=o.exit.bind(o),i.handleError=o.handleError.bind(o),debug("aio handleError intercepted in capture mode"),i.parsed={argv:r,args:t,flags:s},i.logJSON=this.makeLogJSON(o),i.table=this.saveTable(o),o.command=this.command,debug("aio capture intercepts installed"),await i.run()):(i.handleError=this.handleError.bind(i),debug("handleError intercepted in non-capture mode"),await i.run(e))}async dispatch(e,r,t,s){debug("dispatch with argv: %O, skip: %d, argTemplates: %O, parsedOptions: %O",e,r,t,s);const o=e.slice(r);this.command=e.slice(0,r),e=s._.slice(r),t||(t=[]);const a={};for(let r=0;r<t.length;r++){const s=e[r];s&&(a[t[r].name]=s)}const i=new CaptureLogger;return debug("dispatching to runCommand with rawArgv %O, argv: %O, args: %O, flags: %O",o,e,a,s),await this.runCommand(o,e,a,s,i),i}async init(){const{flags:e}=this.parse(this.constructor);e.verbose?verboseError.enabled=!0:e.debug&&createDebug.enable(e.debug)}handleError(e,r){return this.parse(this.constructor),e=improveErrorMsg(e,r),verboseError(r),this.error(e,{exit:1})}displayError(e,r){return this.parse(this.constructor),e=improveErrorMsg(e,r),verboseError(r),this.error(e,{exit:!1})}}function improveErrorMsg(e,r){debug("msg: %s, err: %O",e,r);const t=e=>`${e} ${http_1.STATUS_CODES[e]||""}`.trim();if(r){let s=r.message||"";"OpenWhiskError"===r.name&&(r.error&&r.error.error?(s=r.error.error.toLowerCase(),r.statusCode?s=`${s} (${t(r.statusCode)})`:r.error.code&&(s=`${s} (${r.error.code})`)):r.statusCode&&(s=t(r.statusCode))),(s||"").toString().trim()&&(e=e?`${e}: ${s}`:s)}return debug("improved msg: %s",e),e}async function disambiguateNamespace(e,r){if(e.endsWith("-")){const t=await credentials_1.getCredentialList(credentials_1.authPersister);e=e.slice(0,-1);let s=t.filter(r=>r.namespace.startsWith(e));if(r&&(s=s.filter(e=>e.apihost===r)),s.length>0){if(s.every(e=>e.namespace===s[0].namespace))return s[0].namespace;throw new Error(`Prefix '${e}' matches multiple namespaces`)}}return e}function parseAPIHost(e){if(e)return e.includes(":")?e:e.includes(".")?"https://"+e:(e.startsWith("api")||(e="api"+e),"https://"+e+".nimbella.io")}function fixAioCredentials(e,r){if(process.env.AIO_RUNTIME_NAMESPACE="_",r&&r.apihost&&r.auth)return;const t=credentials_1.authPersister.loadCredentialStoreIfPresent();let s,o,a;if(t&&(s=t.currentHost,o=t.currentNamespace),s&&o){const e=t.credentials[s][o];e?(debug("have creds for current namespace"),a=e.api_key):debug(`Error retrieving credentials for '${o}' on host '${s}'`)}else e.handleError("You do not have a current namespace.  Use 'nim auth login' to create a new one or 'nim auth switch' to use an existing one");process.env.AIO_RUNTIME_APIHOST=s,process.env.AIO_RUNTIME_AUTH=a}exports.NimBaseCommand=NimBaseCommand,NimBaseCommand.args=[],NimBaseCommand.flags={debug:command_1.flags.string({description:"Debug level output",hidden:!0}),verbose:command_1.flags.boolean({char:"v",description:"Greater detail in error messages"}),help:command_1.flags.boolean({description:"Show help"})},exports.disambiguateNamespace=disambiguateNamespace,exports.parseAPIHost=parseAPIHost;
