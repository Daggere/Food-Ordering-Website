"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.seemsToBeProject=exports.readContents=exports.makeClient=exports.fetchProject=exports.parseGithubRef=exports.isGithubRef=void 0;const Path=require("path"),fs=require("fs"),Octokit=require("@octokit/rest"),rimrafOrig=require("rimraf"),util_1=require("util"),makeDebug=require("debug"),credentials_1=require("./credentials"),rimraf=util_1.promisify(rimrafOrig),debug=makeDebug("nim:deployer:github"),TEMP="win32"===process.platform?process.env.TEMP:"/tmp",CACHE_DIR="deployer-git-cache";function cacheDir(){return Path.join(TEMP,CACHE_DIR)}const prefixes=["github:","https://github.com/","git@github.com:"];function isGithubRef(e){for(const t of prefixes)if(e.startsWith(t))return!0;return!1}function parseGithubRef(e){const t=e.split("#");let r,o;if(t.length>2)throw new Error("too many # characters in GitHub reference");2===t.length&&(r=t[1],e=t[0]);for(const t of prefixes)if(e.startsWith(t)){o=e.replace(t,"");break}if(!o)throw new Error("internal error: parseGithubRef should not have been called");for(;o.startsWith("/");)o=o.slice(1);const i=o.split("/");if(i.length<2)throw new Error("too few / characters in GitHub reference; at least <owner>/<repo> is required");const n=i[0];let s=i[1];s.endsWith(".git")&&(s=s.slice(0,s.length-4));return{owner:n,repo:s,path:i.slice(2).join("/"),auth:credentials_1.getGithubAuth(credentials_1.authPersister),ref:r}}async function fetchProject(e,t){fs.existsSync(cacheDir())||fs.mkdirSync(cacheDir());const r=`${e.owner}_${e.repo}_${e.path.split("/").join("_")}`,o=Path.join(cacheDir(),r);return await rimraf(o),fs.mkdirSync(o),debug("fetching project %O",e),await fetchDir(makeClient(e,t),e,e.path,o,!0),o}function makeClient(e,t){return new Octokit({auth:e.auth,userAgent:t})}async function readContents(e,t,r){debug("reading %O at %s",t,r);const{owner:o,repo:i,ref:n}=t;let s;try{s=await e.repos.getContents(n?{owner:o,repo:i,path:r,ref:n}:{owner:o,repo:i,path:r})}catch(e){throw 404===e.status?new Error(`The repository path '${formatGithubDef(t)}' is not recognized by GitHub`):403===e.status&&e.message.includes("rate limit exceeded")?new Error(`You can't deploy '${formatGithubDef(t)}' without authenticating to GitHub (requires too high an access rate).`):(debug("Error detected in readContents: %O",e),e)}if(200!==s.status)throw new Error(`Reading path '${r}' from ${t.owner}/${t.repo}' failed with status code ${s.status}`);if(!s.data)throw new Error(`Reading path '${r}' from ${t.owner}/${t.repo}' succeeded but provided no data`);return s.data}function seemsToBeProject(e){if(Array.isArray(e)){const t=e;for(const e of t){if("project.yml"===e.name&&"file"===e.type)return!0;if(["packages","web"].includes(e.name)&&"dir"===e.type)return!0}}return!1}function formatGithubDef(e){let t=`${e.owner}/${e.repo}`;return e.path&&(t+="/"+e.path),e.ref&&(t+="#"+e.ref),t}async function fetchDir(e,t,r,o,i){const n=await readContents(e,t,r);if(!Array.isArray(n))throw debug("unexpected contents: %O",n),new Error(`Path '${r} should be a directory but is not`);if(i&&!seemsToBeProject(n))throw new Error("GitHub location does not contain a 'nim' project");let s=Promise.resolve(void 0);for(const r of n){const i=Path.join(o,r.name);"dir"===r.type?(fs.mkdirSync(i),s=s.then(()=>fetchDir(e,t,r.path,i,!1))):s=s.then(()=>fetchFile(e,t,r.path,i))}await s}async function fetchFile(e,t,r,o){const i=await readContents(e,t,r);if("string"!=typeof i.content||!i.encoding)throw debug("unexpected contents: %O",i),new Error("Response from 'fetchFile' was not interpretable");const n=Buffer.from(i.content,i.encoding);let s=438;(o.endsWith(".sh")||o.endsWith(".cmd"))&&(s=511),fs.writeFileSync(o,n,{mode:s})}exports.isGithubRef=isGithubRef,exports.parseGithubRef=parseGithubRef,exports.fetchProject=fetchProject,exports.makeClient=makeClient,exports.readContents=readContents,exports.seemsToBeProject=seemsToBeProject;
