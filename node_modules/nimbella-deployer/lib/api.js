"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.wipePackage=exports.wipeNamespace=exports.getMessageFromError=exports.prepareToDeploy=exports.buildProject=exports.readProject=exports.deploy=exports.readAndPrepare=exports.readPrepareAndBuild=exports.deployProject=exports.getUserAgent=exports.initializeAPI=void 0;const deploy_1=require("./deploy"),deploy_struct_1=require("./deploy-struct"),project_reader_1=require("./project-reader"),util_1=require("./util"),deploy_to_bucket_1=require("./deploy-to-bucket"),finder_builder_1=require("./finder-builder"),openwhisk=require("openwhisk"),path=require("path"),credentials_1=require("./credentials"),includer_1=require("./includer"),makeDebug=require("debug"),debug=makeDebug("nim:deployer:api");function initializeAPI(e){const r={};for(const e in process.env)e.startsWith("__OW_")&&(r[e]=process.env[e],delete process.env[e]);return process.env.__OW_USER_AGENT=e,r}function getUserAgent(){return process.env.__OW_USER_AGENT||(util_1.inBrowser?"nimbella-workbench":"nimbella-cli")}function deployProject(e,r,t,a,o){return debug("deployProject invoked with incremental %s",o.incremental),readPrepareAndBuild(e,r,t,a,o).then(e=>e.error?(debug("An error was caught prior to deployment: %O",e.error),Promise.resolve(util_1.wrapError(e.error,void 0))):deploy(e))}function readPrepareAndBuild(e,r,t,a,o,i,n){return readAndPrepare(e,r,t,a,o,void 0,n).then(e=>e.error?e:buildProject(e))}function readAndPrepare(e,r,t,a,o,i,n){const s=includer_1.makeIncluder(o.include,o.exclude);return readProject(e,o.env,s,n).then(e=>e.error?e:prepareToDeploy(e,r,t,a,o))}function deploy(e){return debug("Starting deploy"),deploy_1.cleanOrLoadVersions(e).then(deploy_1.doDeploy).then(r=>{if(!e.githubPath){const t=util_1.writeProjectStatus(e.filePath,r,e.includer.isIncludingEverything());t&&e.feedback.progress(`Deployment status recorded in '${t}'`)}return!r.namespace&&e.credentials&&(r.namespace=e.credentials.namespace),r})}async function readProject(e,r,t,a=new deploy_struct_1.DefaultFeedback){debug("Starting readProject, projectPath=%s, envPath=%s",e,r);const o=await project_reader_1.readTopLevel(e,r,t,!1,a).then(project_reader_1.buildStructureParts).then(project_reader_1.assembleInitialStructure).catch(e=>util_1.errorStructure(e));return debug("evaluating the just-read project: %O",o),util_1.needsBuilding(o)&&null===o.reader.getFSLocation()?(debug("project '%s' will be re-read and cached because it's a github project that needs building",e),util_1.inBrowser?util_1.errorStructure(new Error(`Project '${e}' cannot be deployed from the cloud because it requires building`)):project_reader_1.readTopLevel(e,r,t,!0,a).then(project_reader_1.buildStructureParts).then(project_reader_1.assembleInitialStructure).catch(e=>util_1.errorStructure(e))):o}function buildProject(e){let r;if(debug("Starting buildProject with spec %O",e),e.sharedBuilds={},e.webBuild){const t=e.githubPath||e.filePath;r=finder_builder_1.buildWeb(e.webBuild,e.sharedBuilds,"web",path.join(t,"web"),e.flags,e.reader,e.feedback)}const t=finder_builder_1.buildAllActions(e.packages,e.sharedBuilds,e.flags,e.reader,e.feedback);return r?t?Promise.all([r,t]).then(r=>{const[t,a]=r;return e.web=t,e.packages=a,e}).catch(e=>util_1.errorStructure(e)):r.then(r=>(e.web=r,e)).catch(e=>util_1.errorStructure(e)):t?t.then(r=>(e.packages=r,e)).catch(e=>util_1.errorStructure(e)):Promise.resolve(e)}async function prepareToDeploy(e,r,t,a,o){debug("Starting prepare with spec: %O",e);let i=!1,n=!1;if(!t){let s;if("string"==typeof e.targetNamespace)s=e.targetNamespace;else if(e.targetNamespace){const{test:r,production:t}=e.targetNamespace;if(o.production){if(!t)return util_1.errorStructure(new Error("The production flag was specified but there is no production namespace"));s=t,n=!0}else{if(!r)return util_1.errorStructure(new Error("The production flag was not specified and there is no test namespace"));s=r,i=!0}}if(s)t=await credentials_1.getCredentialsForNamespace(s,r.apihost,a);else{let e;if(t=await credentials_1.getCredentials(a).catch(r=>{e=r}),e)return util_1.errorStructure(e)}}if(debug("owOptions: %O",r),debug("credentials.ow: %O",t.ow),t.project){if(t.project!==path.resolve(e.filePath))return util_1.errorStructure(new Error(`Deployment to namespace '${t.namespace}' must be from project '${t.project}'`));if(i&&t.production)return util_1.errorStructure(new Error(`Namespace '${t.namespace}' is a production namespace but 'project.yml' declares it as a test namespace`));if(n&&!t.production)return util_1.errorStructure(new Error(`Namespace '${t.namespace}' is a test namespace but 'project.yml' declares it as a production namespace`))}(i||n)&&credentials_1.recordNamespaceOwnership(await util_1.getBestProjectName(e),t.namespace,t.ow.apihost,n,a);const s=Object.assign({},t.ow,r||{});debug('wskoptions" %O',s),e.credentials=t,debug("prepareToDeploy merging flags: %O",o),e.flags=o,debug("Options merged");const c=e.web&&e.web.length>0&&!e.actionWrapPackage&&!o.webLocal;if(c&&!t.storageKey)return util_1.errorStructure(new Error(`Deployment of web content to namespace '${t.namespace}' requires a storage key but none is present`));if(debug("Auth sufficiency established"),e.owClient=openwhisk(s),t.namespace?await util_1.isTargetNamespaceValid(e.owClient,t.namespace):t.namespace=await util_1.getTargetNamespace(e.owClient),debug("Target namespace validated"),!o.production&&util_1.saveUsFromOurselves(t.namespace,t.ow.apihost))return util_1.errorStructure(new Error(`To deploy to namespace '${t.namespace}' on host '${t.ow.apihost}' you must specifiy the '--production' flag`));if(debug("Sensitive project/namespace guard passed"),c){let r;const a=await deploy_to_bucket_1.openBucketClient(t,e.bucket).catch(()=>{r=new Error("Could not access object storage using the supplied credentials")});if(r)return util_1.errorStructure(r);e.bucketClient=a}debug("Bucket client created");const{web:u,packages:p}=e;if(!(u&&u.length>0&&e.actionWrapPackage))return debug("returning spec %O",e),Promise.resolve(e);try{const r=u.map(r=>{if(!r.mimeType)throw new Error(`Could not deploy web resource ${r.filePath}; mime type cannot be determined`);return deploy_1.actionWrap(r,e.reader)}),t=e.actionWrapPackage;return Promise.all(r).then(r=>{const a=p.filter(e=>e.name===t);if(0===a.length)p.push({name:t,actions:r,shared:!1});else{const e=a[0].actions.concat(r);a[0].actions=e}return e})}catch(e){return util_1.errorStructure(e)}}function getMessageFromError(e){return"string"==typeof e?e:e.error&&e.error.error&&e.error.code?"[OpenWhisk] "+e.error.error:e.message}async function wipeNamespace(e,r){debug("Requested wipe-namespace function with host %s and auth %s",e,r);const t=openwhisk({apihost:e,api_key:r});return debug("Client opened"),util_1.wipe(t)}async function wipePackage(e,r,t){debug("wipePackage invoked with name='%s', host='%s', auth='%s",e,r,t);const a=openwhisk({apihost:r,api_key:t});return deploy_1.cleanPackage(a,e,void 0)}exports.initializeAPI=initializeAPI,exports.getUserAgent=getUserAgent,exports.deployProject=deployProject,exports.readPrepareAndBuild=readPrepareAndBuild,exports.readAndPrepare=readAndPrepare,exports.deploy=deploy,exports.readProject=readProject,exports.buildProject=buildProject,exports.prepareToDeploy=prepareToDeploy,exports.getMessageFromError=getMessageFromError,exports.wipeNamespace=wipeNamespace,exports.wipePackage=wipePackage;
