"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.buildWeb=exports.getBuildForWeb=exports.buildAllActions=exports.getBuildForAction=void 0;const child_process_1=require("child_process"),util_1=require("./util"),path=require("path"),fs=require("fs"),ignore_1=require("ignore"),archiver=require("archiver"),touch=require("touch"),makeDebug=require("debug"),github_1=require("./github"),memoryStreams=require("memory-streams"),debug=makeDebug("nim:deployer:finder-builder"),zipDebug=makeDebug("nim:deployer:zip"),ZIP_TARGET="__deployer__.zip";function getBuildForAction(e,i){return readDirectory(e,i).then(i=>findSpecialFile(i,e,!0))}function buildAllActions(e,i,n,t,r){if(!e||0===e.length)return;const o=util_1.mapPackages(e),s=[];for(const o of e)if(o.actions&&o.actions.length>0){const e=buildActionsOfPackage(o,i,n,t,r);s.push(e)}return 0!==s.length?Promise.all(s).then(e=>{for(const i of e)i&&(o[i.name]=i);return Object.values(o)}):void 0}async function buildActionsOfPackage(e,i,n,t,r){const o=util_1.mapActions(e.actions);let s=!0;for(const l of e.actions)if(l.build){s=!1;const e=await buildAction(l,i,n,t,r);o[l.name]=e}if(!s)return e.actions=Object.values(o),e}function buildAction(e,i,n,t,r){if(!e.build)return Promise.resolve(e);let o;switch(debug("building action %O",e),e.build){case"build.sh":return o=makeLocal(t,e.file),scriptBuilder("./build.sh",o,e.displayFile,n,r).then(()=>identifyActionFiles(e,n.incremental,n.verboseZip,t,r));case"build.cmd":return o=makeLocal(t,e.file),scriptBuilder("build.cmd",o,e.displayFile,n,r).then(()=>identifyActionFiles(e,n.incremental,n.verboseZip,t,r));case".build":return o=makeLocal(t,e.file),outOfLineBuilder(o,e.displayFile,i,!0,n,t,r).then(()=>identifyActionFiles(e,n.incremental,n.verboseZip,t,r));case"package.json":return o=makeLocal(t,e.file),npmBuilder(o,e.displayFile,n,r).then(()=>identifyActionFiles(e,n.incremental,n.verboseZip,t,r));case".include":case"identify":return identifyActionFiles(e,n.incremental,n.verboseZip,t,r);default:throw new Error("Unknown build type in ActionSpec: "+e.build)}}function processInclude(e,i,n){return debug("processing includes from '%s'",e),readFileAsList(e,n).then(e=>processIncludeFileItems(e,i,n))}function joinAndNormalize(...e){return path.normalize(path.join(...e))}function makeLocal(e,...i){const n=e.getFSLocation();if(!n)throw new Error("invalid call to makeLocal");return path.resolve(n,...i)}async function processIncludeFileItems(e,i,n){const t=[],r=[];for(const o of e){if(!o||0===o.length)continue;debug("processing include item %s",o);let e=path.isAbsolute(o)?o:joinAndNormalize(i,o);(e.endsWith("/")||e.endsWith("\\"))&&(e=e.slice(0,-1)),debug("Calculated oldPath '%s'",e);const s=await n.getPathKind(e);if(!s)return Promise.reject(new Error(`${e} is included for '${i}' but does not exist`));let l;l=o.includes("..")||path.isAbsolute(o)?path.basename(o):o;const u=e.length-l.length;if(debug("Calculated newPath '%s' with elision %d",l,u),s.isFile)r.push([e,l]);else{if(!s.isDirectory)return Promise.reject(new Error(`'${o}' is neither a file nor a directory`));{const i=util_1.promiseFilesAndFilterFiles(e,n).then(e=>e.map(e=>[e,e.slice(u)]));debug("Expanded directory '%s'",e),t.push(i)}}}return Promise.all(t.concat(Promise.resolve(r))).then(e=>e.reduce((e,i)=>e.concat(i),[]))}async function identifyActionFiles(e,i,n,t,r){let o=path.join(e.file,".include");return await t.isExistingFile(o)||(o=path.join(e.file,".source")),await t.isExistingFile(o)?processInclude(o,e.file,t).then(s=>0===s.length?Promise.reject(new Error(o+" is empty")):s.length>1?autozipBuilder(s,e,i,n,t,r):singleFileBuilder(e,s[0][0])):getIgnores(e.file,t).then(o=>util_1.promiseFilesAndFilterFiles(e.file,t).then(s=>{if(0===(s=applyIgnores(e.file,s,o)).length)return Promise.reject(new Error(`Action '${e.name}' has no included files`));if(1===s.length)return singleFileBuilder(e,s[0]);return autozipBuilder(s.map(i=>{const n=i.substring(e.file.length+1);return[i,n]}),e,i,n,t,r)}))}function applyIgnores(e,i,n){const t=path.isAbsolute(e);return t&&(i=i.map(i=>path.relative(e,i))),i=n.filter(i),t&&(i=i.map(i=>path.join(e,i))),i}function readFileAsList(e,i){return i.readFileContents(e).then(e=>String(e).split("\n").filter(e=>e&&e.trim().length>0).map(e=>e.trim()))}function outOfLineBuilder(e,i,n,t,r,o,s){const l=path.join(e,".build");return readFileAsList(l,o).then(async u=>{if(0===u.length||u.length>1)return Promise.reject(new Error(l+" contains too many or too few lines"));const c=joinAndNormalize(e,u[0]),a=await o.getPathKind(c);return a.isFile?scriptBuilder(c,e,i,r,s):a.isDirectory?readDirectory(c,o).then(l=>{const u=findSpecialFile(l,e,t);let a;const d=makeLocal(o,c);switch(u){case"build.sh":case"build.cmd":{const e=makeLocal(o,c,u);a=()=>scriptBuilder(e,d,i,r,s);break}case"package.json":a=()=>npmBuilder(d,i,r,s);break;default:return Promise.reject(new Error(c+" is a directory but contains no build information"))}if(isSharedBuild(l)){const i=makeLocal(o,c);let t=n[i];return t?(s.progress(`Skipping shared build for '${e}' ... already run in this deployment`),debug("buildStatus is %O",t),t.built?(debug("Found completed build"),Promise.resolve(!0)):t.error?(debug("Found error in build"),Promise.reject(t.error)):(debug("Found shared build still running"),new Promise((function(e,i){t.pending.push((function(n){n?i(n):e(!0)}))})))):(s.progress(`Running shared build for '${e}', results may be reused`),t={pending:[],built:!1,error:void 0},n[i]=t,a().then(e=>{debug("shared build completed successfully with resultPromise %O",e),t.built=!0;const i=t.pending;return t.pending=[],i.forEach(e=>e(void 0)),!0}).catch(e=>{debug("shared build completed with error"),t.error=e;throw t.pending.forEach(i=>i(e)),e}))}return s.progress("Build is not shared"),a()}):void 0})}function isSharedBuild(e){let i=!1;return e.forEach(e=>{e.isDirectory||".shared"!==e.name||(i=!0)}),i}function getBuildForWeb(e,i){return e?readDirectory(e,i).then(i=>findSpecialFile(i,e,!1)):Promise.resolve(void 0)}function buildWeb(e,i,n,t,r,o,s){let l;switch(debug("Performing Web build"),e){case"build.sh":return l=makeLocal(o,n),scriptBuilder("./build.sh",l,t,r,s).then(()=>identifyWebFiles(n,o));case"build.cmd":return debug("cwd for windows build is %s",n),l=makeLocal(o,n),scriptBuilder("build.cmd",l,t,r,s).then(()=>identifyWebFiles(n,o));case".build":return outOfLineBuilder(n,t,i,!1,r,o,s).then(()=>identifyWebFiles(n,o));case"package.json":return l=makeLocal(o,n),npmBuilder(l,t,r,s).then(()=>identifyWebFiles(n,o));case".include":case"identify":return identifyWebFiles(n,o);default:throw new Error("Unknown build type for web directory: "+e)}}async function identifyWebFiles(e,i){debug("Identifying web files");const n=path.join(e,".include");return await i.isExistingFile(n)?(debug("processing .include"),processInclude(n,e,i).then(e=>util_1.convertPairsToResources(e))):(debug("Processing web files using .ignore"),getIgnores(e,i).then(n=>(debug("processing .ignore and/or ignore rules"),util_1.promiseFilesAndFilterFiles(e,i).then(i=>(checkForNodeModules(i=applyIgnores(e,i,n)),debug(`Converting ${i.length} items to resources`),util_1.convertToResources(i,e.length+1))))))}function checkForNodeModules(e){e.forEach(e=>{if(e.includes("node_modules"))throw new Error("Deploying 'node_modules' to the web, which is probably an error.  Use '.include' or '.ignore' to avoid this problem.")})}function readDirectory(e,i){return i.readdir(e).then(util_1.filterFiles)}function agreeOnRuntime(e){let i;return e.forEach(e=>{const{runtime:n}=util_1.actionFileToParts(e);if(n){if(i&&n!==i)return;i=n}}),i}function findSpecialFile(e,i,n){const t=e.filter(e=>!e.isDirectory);let r=!1,o=!1,s=!1,l=!1,u=!1,c=!1;for(const e of t)"build.sh"===e.name?r=!0:"build.cmd"===e.name?o=!0:"package.json"===e.name?s=!0:".include"===e.name||".source"===e.name?l=!0:".ignore"===e.name?c=!0:".build"===e.name&&(u=!0);if(u&&(r||o))throw new Error(`In ${i}: '.build' should not be present alongside 'build.sh' or 'build.cmd'`);if(l&&c)throw new Error(`In ${i}: '.include' (or '.source') and '.ignore' may not both be present`);if(n&&(0===t.length||c&&1===t.length))throw new Error(`Action directory ${i} has no files`);if("win32"===process.platform){if(r&&!o)throw new Error(`In ${i}: 'build.sh' won't run on this platform and no 'build.cmd' is provided`);if(o)return"build.cmd"}else{if(!r&&o)throw new Error(`In ${i}: 'build.cmd' won't run on this platform and no 'build.sh' is provided`);if(r)return"build.sh"}return u?".build":s?"package.json":l?".include":"identify"}function singleFileBuilder(e,i){debug("singleFileBuilder deploying '%s'",i);const n=util_1.actionFileToParts(i);delete n.name,n.web=!0;const{binary:t,zipped:r}=n,o=Object.assign(n,e,{file:i,binary:t,zipped:r});return Promise.resolve(o)}async function autozipBuilder(e,i,n,t,r,o){t?o.progress("Zipping action contents in",i.file):debug("Zipping action contents in %s",i.file),i.runtime||(i.runtime=agreeOnRuntime(e.map(e=>e[0])));const s=path.join(i.file,ZIP_TARGET),l=null===r.getFSLocation();let u;if(l)zipDebug("zipping to memory buffer for action %s",i.name),u=new memoryStreams.WritableStream;else{zipDebug("zipping to %s for action %s",s,i.name);const t=makeLocal(r,s);if(e=e.map(e=>[makeLocal(r,e[0]),e[1]]),fs.existsSync(t)){if(zipDebug("the file exists and will be either reused or deleted"),n){const n=[makeLocal(r,i.file,".include"),makeLocal(r,i.file,".ignore")].filter(fs.existsSync);if(debug("checking whether to build a new zip for %s with metaFiles %o",i.name,n),zipFileAppearsCurrent(t,e.map(e=>e[0]).concat(n)))return singleFileBuilder(i,s)}zipDebug("deleting old target zip"),fs.unlinkSync(t)}u=fs.createWriteStream(t)}const c=archiver("zip"),a=new Promise((function(e,i){c.on("error",e=>{zipDebug("zip error occurred: %O",e),i(e)}),u.on("close",()=>{zipDebug("zipfile successfully closed"),e(void 0)}),u.on("finish",()=>{zipDebug("zipfile successfully finished"),e(void 0)}),u.on("end",()=>{zipDebug("zipfile data has been drained")}),c.on("warning",e=>{zipDebug("warning issued from archiver %O",e),"ENOENT"!==e.code&&i(e)})}));c.pipe(u),zipDebug("zipping %d files",e.length);for(const n of e){const[e,t]=n,o=(await r.getPathKind(e)).mode,s=await r.readFileContents(e);zipDebug("Zipping file with old path '%s', buffer length '%d', new path '%s', and mode %d",e,s.length,t,o),c.append(s,{name:t,mode:o}),zipDebug("Zipped '%s' for action '%s', emitted %d",t,i.name,c.pointer())}return zipDebug("finalizing zip for action %s",i.name),c.finalize(),zipDebug("zip finalized for action %s",i.name),a.then(()=>{if(t?o.progress("Zipping complete in",i.file):debug("zipping complete for %s",i.name),l){const e=u.toBuffer().toString("base64");return e?(zipDebug("in memory zipping complete with code of length %d",e.length),i.code=e,singleFileBuilder(i,i.file)):Promise.reject(new Error("An error occurred in in-memory zipping"))}return singleFileBuilder(i,s)})}function build(e,i,n,t,r,o,s,l){debug("building with realPath=%s and displayPath=%s",n,t);let u="";const c=Date.now();function a(e){u+=e.toString();Date.now()-c>5e3&&l.progress("Still running",r,"in",t)}return new Promise((function(c,d){l.progress("Started running",r,"in",t);const p="win32"===process.platform||(process.env.shell||"/bin/bash"),f=child_process_1.spawn(e,i,{cwd:n,shell:p});s?(f.stdout.on("data",e=>l.progress(String(e))),f.stderr.on("data",e=>l.warn(String(e)))):(f.stdout.on("data",a),f.stderr.on("data",a)),f.on("close",e=>{0!==e?(s||(l.warn("Output of failed build in %s",n),github_1.isGithubRef(t)&&l.warn("%s is a cache location for %s",n,t),l.warn(u)),d(new Error(`'${o}' exited with code ${e}`))):(l.progress("Finished running",r,"in",t),c(void 0))}),f.on("error",e=>{d(e)})}))}function scriptBuilder(e,i,n,t,r){return t.incremental&&scriptAppearsBuilt(i)?(t.verboseBuild&&r.progress(`Skipping build in ${n} because the action was previously built`),Promise.resolve(!0)):build(e,[],i,n,e,e,t.verboseBuild,r)}function scriptAppearsBuilt(e){const i=path.join(e,".built");return fs.existsSync(i)}function zipFileAppearsCurrent(e,i){const n=fs.statSync(e).mtimeMs;for(const t of i){if(!fs.existsSync(t))return debug("dependency %s doesn't exist",t),!1;if(fs.statSync(t).mtimeMs>n)return debug("%s not considered current because %s is newer",e,t),!1}return debug("%s seems up to date so no re-zip",e),!0}function npmPackageAppearsBuilt(e){const i=path.join(e,"package.json"),n=path.join(e,"package-lock.json"),t=path.join(e,"yarn.lock"),r=path.join(e,"node_modules"),o=fs.statSync(i).mtimeMs,s=fs.existsSync(n)?fs.statSync(n).mtimeMs:0,l=fs.existsSync(r)?fs.statSync(r).mtimeMs:0,u=fs.existsSync(t)?fs.statSync(t).mtimeMs:0;return(u>s?u:s)>=o&&l>=o}function makeNpmPackageAppearBuilt(e){const i=path.join(e,"package-lock.json");fs.existsSync(i)&&touch(i);const n=path.join(e,"yarn.lock");fs.existsSync(n)&&touch(n);const t=path.join(e,"node_modules");fs.existsSync(t)&&touch(t)}function npmBuilder(e,i,n,t){debug("Performing npm build for %s",e);const r=n.yarn?"yarn":"npm",o=buildScriptExists(e),s=o?["install","&&",r,"run","build"]:["install","--production"],l=[r,...s].join(" ");if(n.incremental){debug("Detected incremental build");const i=npmPackageAppearsBuilt(e),r=scriptAppearsBuilt(e),s=o?i&&r:i;if(debug(`npmRunBuild=${!!o}, npmPackageAppearsBuilt=${i}, scriptAppearsBuilt=${r}, shouldSkip=${s}`),s)return n.verboseBuild&&t.progress(`Skipping '${l}' in ${e} because the previous build is still valid`),Promise.resolve(!0)}else debug("Build was not incremental");return build(r,s,e,i,l,r+" install",n.verboseBuild,t).then(()=>makeNpmPackageAppearBuilt(e))}function buildScriptExists(e){const i=fs.readFileSync(path.join(e,"package.json")),n=JSON.parse(String(i));return n.scripts&&n.scripts.build}function getIgnores(e,i){const n=path.join(e,".ignore"),t=[".ignore",".build","build.sh","build.cmd",ZIP_TARGET,...util_1.FILES_TO_SKIP];return readFileAsList(n,i).then(e=>ignore_1.default().add(e.concat(t))).catch(()=>ignore_1.default().add(t))}exports.getBuildForAction=getBuildForAction,exports.buildAllActions=buildAllActions,exports.getBuildForWeb=getBuildForWeb,exports.buildWeb=buildWeb;
